{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/root/gshark/Three.js/Gigashark-v2/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/root/gshark/Three.js/Gigashark-v2/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _get = require(\"/root/gshark/Three.js/Gigashark-v2/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"/root/gshark/Three.js/Gigashark-v2/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"/root/gshark/Three.js/Gigashark-v2/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/root/gshark/Three.js/Gigashark-v2/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storeAsStream = void 0;\n\nvar stream_1 = require(\"stream\");\n\nvar ObservableStoreStream = /*#__PURE__*/function (_stream_1$Duplex) {\n  _inherits(ObservableStoreStream, _stream_1$Duplex);\n\n  var _super = _createSuper(ObservableStoreStream);\n\n  function ObservableStoreStream(obsStore) {\n    var _this;\n\n    _classCallCheck(this, ObservableStoreStream);\n\n    _this = _super.call(this, {\n      // pass values, not serializations\n      objectMode: true\n    }); // dont buffer outgoing updates\n\n    _this.resume(); // save handler so we can unsubscribe later\n\n\n    _this.handler = function (state) {\n      return _this.push(state);\n    }; // subscribe to obsStore changes\n\n\n    _this.obsStore = obsStore;\n\n    _this.obsStore.subscribe(_this.handler);\n\n    return _this;\n  } // emit current state on new destination\n\n\n  _createClass(ObservableStoreStream, [{\n    key: \"pipe\",\n    value: function pipe(dest, options) {\n      var result = _get(_getPrototypeOf(ObservableStoreStream.prototype), \"pipe\", this).call(this, dest, options);\n\n      dest.write(this.obsStore.getState());\n      return result;\n    } // write from incoming stream to state\n\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      this.obsStore.putState(chunk);\n      callback();\n    } // noop - outgoing stream is asking us if we have data we arent giving it\n\n  }, {\n    key: \"_read\",\n    value: function _read(_size) {\n      return undefined;\n    } // unsubscribe from event emitter\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err, callback) {\n      this.obsStore.unsubscribe(this.handler);\n\n      _get(_getPrototypeOf(ObservableStoreStream.prototype), \"_destroy\", this).call(this, err, callback);\n    }\n  }]);\n\n  return ObservableStoreStream;\n}(stream_1.Duplex);\n\nfunction storeAsStream(obsStore) {\n  return new ObservableStoreStream(obsStore);\n}\n\nexports.storeAsStream = storeAsStream;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;IAIMA,qB;;;;;EAKJ,+BAAYC,QAAZ,EAAwC;IAAA;;IAAA;;IACtC,0BAAM;MACJ;MACAC,UAAU,EAAE;IAFR,CAAN,EADsC,CAKtC;;IACA,MAAKC,MAAL,GANsC,CAOtC;;;IACA,MAAKC,OAAL,GAAe,UAACC,KAAD;MAAA,OAAc,MAAKC,IAAL,CAAUD,KAAV,CAAd;IAAA,CAAf,CARsC,CAStC;;;IACA,MAAKJ,QAAL,GAAgBA,QAAhB;;IACA,MAAKA,QAAL,CAAcM,SAAd,CAAwB,MAAKH,OAA7B;;IAXsC;EAYvC,C,CAED;;;;;WACA,cACEI,IADF,EAEEC,OAFF,EAE6B;MAE3B,IAAMC,MAAM,mFAAcF,IAAd,EAAoBC,OAApB,CAAZ;;MACAD,IAAI,CAACG,KAAL,CAAW,KAAKV,QAAL,CAAcW,QAAd,EAAX;MACA,OAAOF,MAAP;IACD,C,CAED;;;;WACA,gBACEG,KADF,EAEEC,SAFF,EAGEC,QAHF,EAG0C;MAExC,KAAKd,QAAL,CAAce,QAAd,CAAuBH,KAAvB;MACAE,QAAQ;IACT,C,CAED;;;;WACA,eAAME,KAAN,EAAmB;MACjB,OAAOC,SAAP;IACD,C,CAED;;;;WACA,kBAASC,GAAT,EAA4BJ,QAA5B,EAAmE;MACjE,KAAKd,QAAL,CAAcmB,WAAd,CAA0B,KAAKhB,OAA/B;;MACA,oFAAee,GAAf,EAAoBJ,QAApB;IACD;;;;EAhDoCM,e;;AAmDvC,SAAgBC,aAAhB,CACErB,QADF,EAC8B;EAE5B,OAAO,IAAID,qBAAJ,CAA0BC,QAA1B,CAAP;AACD;;AAJDsB","names":["ObservableStoreStream","obsStore","objectMode","resume","handler","state","push","subscribe","dest","options","result","write","getState","chunk","_encoding","callback","putState","_size","undefined","err","unsubscribe","stream_1","storeAsStream","exports"],"sourceRoot":"","sources":["../src/asStream.ts"],"sourcesContent":["import { Duplex as DuplexStream } from 'stream';\n\nimport { ObservableStore } from './ObservableStore';\n\nclass ObservableStoreStream<T> extends DuplexStream {\n  handler: (state: T) => void;\n\n  obsStore: ObservableStore<T>;\n\n  constructor(obsStore: ObservableStore<T>) {\n    super({\n      // pass values, not serializations\n      objectMode: true,\n    });\n    // dont buffer outgoing updates\n    this.resume();\n    // save handler so we can unsubscribe later\n    this.handler = (state: T) => this.push(state);\n    // subscribe to obsStore changes\n    this.obsStore = obsStore;\n    this.obsStore.subscribe(this.handler);\n  }\n\n  // emit current state on new destination\n  pipe<U extends NodeJS.WritableStream>(\n    dest: U,\n    options?: { end?: boolean },\n  ): U {\n    const result = super.pipe(dest, options);\n    dest.write(this.obsStore.getState() as any);\n    return result;\n  }\n\n  // write from incoming stream to state\n  _write(\n    chunk: any,\n    _encoding: string,\n    callback: (error?: Error | null) => void,\n  ): void {\n    this.obsStore.putState(chunk);\n    callback();\n  }\n\n  // noop - outgoing stream is asking us if we have data we arent giving it\n  _read(_size: number): void {\n    return undefined;\n  }\n\n  // unsubscribe from event emitter\n  _destroy(err: Error | null, callback: (error: Error | null) => void): void {\n    this.obsStore.unsubscribe(this.handler);\n    super._destroy(err, callback);\n  }\n}\n\nexport function storeAsStream<T>(\n  obsStore: ObservableStore<T>,\n): ObservableStoreStream<T> {\n  return new ObservableStoreStream(obsStore);\n}\n"]},"metadata":{},"sourceType":"script"}