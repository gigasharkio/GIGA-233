{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\n\nvar nacl = __importStar(require(\"tweetnacl\"));\n\nvar naclUtil = __importStar(require(\"tweetnacl-util\"));\n\nvar utils_1 = require(\"./utils\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\n\n\nfunction encrypt(_ref) {\n  var publicKey = _ref.publicKey,\n      data = _ref.data,\n      version = _ref.version;\n\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        if (typeof data !== 'string') {\n          throw new Error('Message data must be given as a string');\n        } // generate ephemeral keypair\n\n\n        var ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8\n\n        var pubKeyUInt8Array;\n\n        try {\n          pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n\n        var msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n        var nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt\n\n        var encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data\n\n        var output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: naclUtil.encodeBase64(nonce),\n          ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: naclUtil.encodeBase64(encryptedMessage)\n        }; // return encrypted msg data\n\n        return output;\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\n\nfunction encryptSafely(_ref2) {\n  var publicKey = _ref2.publicKey,\n      data = _ref2.data,\n      version = _ref2.version;\n\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  var DEFAULT_PADDING_LENGTH = Math.pow(2, 11);\n  var NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n  } // add padding\n\n\n  var dataWithPadding = {\n    data: data,\n    padding: ''\n  }; // calculate padding\n\n  var dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n  var modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  var padLength = 0; // Only pad if necessary\n\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n\n  dataWithPadding.padding = '0'.repeat(padLength);\n  var paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({\n    publicKey: publicKey,\n    data: paddedMessage,\n    version: version\n  });\n}\n\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\n\nfunction decrypt(_ref3) {\n  var encryptedData = _ref3.encryptedData,\n      privateKey = _ref3.privateKey;\n\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        // string to buffer to UInt8Array\n        var recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n        var recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters\n\n        var nonce = naclUtil.decodeBase64(encryptedData.nonce);\n        var ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n        var ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey); // decrypt\n\n        var decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data\n\n        var output;\n\n        try {\n          output = naclUtil.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n\n        if (output) {\n          return output;\n        }\n\n        throw new Error('Decryption failed.');\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\n\nfunction decryptSafely(_ref4) {\n  var encryptedData = _ref4.encryptedData,\n      privateKey = _ref4.privateKey;\n\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  var dataWithPadding = JSON.parse(decrypt({\n    encryptedData: encryptedData,\n    privateKey: privateKey\n  }));\n  return dataWithPadding.data;\n}\n\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\n\nfunction getEncryptionPublicKey(privateKey) {\n  var privateKeyUint8Array = nacl_decodeHex(privateKey);\n  var encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\n\nfunction nacl_decodeHex(msgHex) {\n  var msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;AASA;;;;;;;;;;;AASA,SAAgBA,OAAhB,OAQC;EAAA,IAPCC,SAOD,QAPCA,SAOD;EAAA,IANCC,IAMD,QANCA,IAMD;EAAA,IALCC,OAKD,QALCA,OAKD;;EACC,IAAIC,kBAAUH,SAAV,CAAJ,EAA0B;IACxB,MAAM,IAAII,KAAJ,CAAU,6BAAV,CAAN;EACD,CAFD,MAEO,IAAID,kBAAUF,IAAV,CAAJ,EAAqB;IAC1B,MAAM,IAAIG,KAAJ,CAAU,wBAAV,CAAN;EACD,CAFM,MAEA,IAAID,kBAAUD,OAAV,CAAJ,EAAwB;IAC7B,MAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;EACD;;EAED,QAAQF,OAAR;IACE,KAAK,0BAAL;MAAiC;QAC/B,IAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;UAC5B,MAAM,IAAIG,KAAJ,CAAU,wCAAV,CAAN;QACD,CAH8B,CAI/B;;;QACA,IAAMC,gBAAgB,GAAGC,IAAI,CAACC,GAAL,CAASC,OAAT,EAAzB,CAL+B,CAO/B;;QACA,IAAIC,gBAAJ;;QACA,IAAI;UACFA,gBAAgB,GAAGC,QAAQ,CAACC,YAAT,CAAsBX,SAAtB,CAAnB;QACD,CAFD,CAEE,OAAOY,GAAP,EAAY;UACZ,MAAM,IAAIR,KAAJ,CAAU,gBAAV,CAAN;QACD;;QAED,IAAMS,mBAAmB,GAAGH,QAAQ,CAACI,UAAT,CAAoBb,IAApB,CAA5B;QACA,IAAMc,KAAK,GAAGT,IAAI,CAACU,WAAL,CAAiBV,IAAI,CAACC,GAAL,CAASU,WAA1B,CAAd,CAhB+B,CAkB/B;;QACA,IAAMC,gBAAgB,GAAGZ,IAAI,CAACC,GAAL,CACvBM,mBADuB,EAEvBE,KAFuB,EAGvBN,gBAHuB,EAIvBJ,gBAAgB,CAACc,SAJM,CAAzB,CAnB+B,CA0B/B;;QACA,IAAMC,MAAM,GAAG;UACblB,OAAO,EAAE,0BADI;UAEba,KAAK,EAAEL,QAAQ,CAACW,YAAT,CAAsBN,KAAtB,CAFM;UAGbO,cAAc,EAAEZ,QAAQ,CAACW,YAAT,CAAsBhB,gBAAgB,CAACL,SAAvC,CAHH;UAIbuB,UAAU,EAAEb,QAAQ,CAACW,YAAT,CAAsBH,gBAAtB;QAJC,CAAf,CA3B+B,CAiC/B;;QACA,OAAOE,MAAP;MACD;;IAED;MACE,MAAM,IAAIhB,KAAJ,CAAU,uCAAV,CAAN;EAvCJ;AAyCD;;AA1DDoB;AA4DA;;;;;;;;;;;;;AAYA,SAAgBC,aAAhB,QAQC;EAAA,IAPCzB,SAOD,SAPCA,SAOD;EAAA,IANCC,IAMD,SANCA,IAMD;EAAA,IALCC,OAKD,SALCA,OAKD;;EACC,IAAIC,kBAAUH,SAAV,CAAJ,EAA0B;IACxB,MAAM,IAAII,KAAJ,CAAU,6BAAV,CAAN;EACD,CAFD,MAEO,IAAID,kBAAUF,IAAV,CAAJ,EAAqB;IAC1B,MAAM,IAAIG,KAAJ,CAAU,wBAAV,CAAN;EACD,CAFM,MAEA,IAAID,kBAAUD,OAAV,CAAJ,EAAwB;IAC7B,MAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;EACD;;EAED,IAAMsB,sBAAsB,YAAG,CAAH,EAAQ,EAAR,CAA5B;EACA,IAAMC,gBAAgB,GAAG,EAAzB;;EAEA,IAAI,OAAO1B,IAAP,KAAgB,QAAhB,IAA4B,YAAYA,IAA5C,EAAkD;IAChD;IACA;IACA,MAAM,IAAIG,KAAJ,CACJ,qEADI,CAAN;EAGD,CAlBF,CAoBC;;;EACA,IAAMwB,eAAe,GAAG;IACtB3B,IAAI,EAAJA,IADsB;IAEtB4B,OAAO,EAAE;EAFa,CAAxB,CArBD,CA0BC;;EACA,IAAMC,UAAU,GAAGC,MAAM,CAACC,UAAP,CACjBC,IAAI,CAACC,SAAL,CAAeN,eAAf,CADiB,EAEjB,OAFiB,CAAnB;EAIA,IAAMO,MAAM,GAAGL,UAAU,GAAGJ,sBAA5B;EACA,IAAIU,SAAS,GAAG,CAAhB,CAhCD,CAiCC;;EACA,IAAID,MAAM,GAAG,CAAb,EAAgB;IACdC,SAAS,GAAGV,sBAAsB,GAAGS,MAAzB,GAAkCR,gBAA9C,CADc,CACkD;EACjE;;EACDC,eAAe,CAACC,OAAhB,GAA0B,IAAIQ,MAAJ,CAAWD,SAAX,CAA1B;EAEA,IAAME,aAAa,GAAGL,IAAI,CAACC,SAAL,CAAeN,eAAf,CAAtB;EACA,OAAO7B,OAAO,CAAC;IAAEC,SAAS,EAATA,SAAF;IAAaC,IAAI,EAAEqC,aAAnB;IAAkCpC,OAAO,EAAPA;EAAlC,CAAD,CAAd;AACD;;AAjDDsB;AAmDA;;;;;;;;;AAQA,SAAgBe,OAAhB,QAMC;EAAA,IALCC,aAKD,SALCA,aAKD;EAAA,IAJCC,UAID,SAJCA,UAID;;EACC,IAAItC,kBAAUqC,aAAV,CAAJ,EAA8B;IAC5B,MAAM,IAAIpC,KAAJ,CAAU,iCAAV,CAAN;EACD,CAFD,MAEO,IAAID,kBAAUsC,UAAV,CAAJ,EAA2B;IAChC,MAAM,IAAIrC,KAAJ,CAAU,8BAAV,CAAN;EACD;;EAED,QAAQoC,aAAa,CAACtC,OAAtB;IACE,KAAK,0BAAL;MAAiC;QAC/B;QACA,IAAMwC,4BAA4B,GAAGC,cAAc,CAACF,UAAD,CAAnD;QACA,IAAMG,4BAA4B,GAAGtC,IAAI,CAACC,GAAL,CAASC,OAAT,CAAiBqC,aAAjB,CACnCH,4BADmC,EAEnCvB,SAFF,CAH+B,CAO/B;;QACA,IAAMJ,KAAK,GAAGL,QAAQ,CAACC,YAAT,CAAsB6B,aAAa,CAACzB,KAApC,CAAd;QACA,IAAMQ,UAAU,GAAGb,QAAQ,CAACC,YAAT,CAAsB6B,aAAa,CAACjB,UAApC,CAAnB;QACA,IAAMD,cAAc,GAAGZ,QAAQ,CAACC,YAAT,CACrB6B,aAAa,CAAClB,cADO,CAAvB,CAV+B,CAc/B;;QACA,IAAMwB,gBAAgB,GAAGxC,IAAI,CAACC,GAAL,CAASwC,IAAT,CACvBxB,UADuB,EAEvBR,KAFuB,EAGvBO,cAHuB,EAIvBsB,4BAJuB,CAAzB,CAf+B,CAsB/B;;QACA,IAAIxB,MAAJ;;QACA,IAAI;UACFA,MAAM,GAAGV,QAAQ,CAACsC,UAAT,CAAoBF,gBAApB,CAAT;QACD,CAFD,CAEE,OAAOlC,GAAP,EAAY;UACZ,MAAM,IAAIR,KAAJ,CAAU,oBAAV,CAAN;QACD;;QAED,IAAIgB,MAAJ,EAAY;UACV,OAAOA,MAAP;QACD;;QACD,MAAM,IAAIhB,KAAJ,CAAU,oBAAV,CAAN;MACD;;IAED;MACE,MAAM,IAAIA,KAAJ,CAAU,wCAAV,CAAN;EAtCJ;AAwCD;;AArDDoB;AAuDA;;;;;;;;;AAQA,SAAgByB,aAAhB,QAMC;EAAA,IALCT,aAKD,SALCA,aAKD;EAAA,IAJCC,UAID,SAJCA,UAID;;EACC,IAAItC,kBAAUqC,aAAV,CAAJ,EAA8B;IAC5B,MAAM,IAAIpC,KAAJ,CAAU,iCAAV,CAAN;EACD,CAFD,MAEO,IAAID,kBAAUsC,UAAV,CAAJ,EAA2B;IAChC,MAAM,IAAIrC,KAAJ,CAAU,8BAAV,CAAN;EACD;;EAED,IAAMwB,eAAe,GAAGK,IAAI,CAACiB,KAAL,CAAWX,OAAO,CAAC;IAAEC,aAAa,EAAbA,aAAF;IAAiBC,UAAU,EAAVA;EAAjB,CAAD,CAAlB,CAAxB;EACA,OAAOb,eAAe,CAAC3B,IAAvB;AACD;;AAfDuB;AAiBA;;;;;;;AAMA,SAAgB2B,sBAAhB,CAAuCV,UAAvC,EAAyD;EACvD,IAAMW,oBAAoB,GAAGT,cAAc,CAACF,UAAD,CAA3C;EACA,IAAMY,mBAAmB,GACvB/C,IAAI,CAACC,GAAL,CAASC,OAAT,CAAiBqC,aAAjB,CAA+BO,oBAA/B,EAAqDpD,SADvD;EAEA,OAAOU,QAAQ,CAACW,YAAT,CAAsBgC,mBAAtB,CAAP;AACD;;AALD7B;AAOA;;;;;;;AAMA,SAASmB,cAAT,CAAwBW,MAAxB,EAAsC;EACpC,IAAMC,SAAS,GAAGxB,MAAM,CAACyB,IAAP,CAAYF,MAAZ,EAAoB,KAApB,EAA2BG,QAA3B,CAAoC,QAApC,CAAlB;EACA,OAAO/C,QAAQ,CAACC,YAAT,CAAsB4C,SAAtB,CAAP;AACD","names":["encrypt","publicKey","data","version","utils_1","Error","ephemeralKeyPair","nacl","box","keyPair","pubKeyUInt8Array","naclUtil","decodeBase64","err","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","output","encodeBase64","ephemPublicKey","ciphertext","exports","encryptSafely","DEFAULT_PADDING_LENGTH","NACL_EXTRA_BYTES","dataWithPadding","padding","dataLength","Buffer","byteLength","JSON","stringify","modVal","padLength","repeat","paddedMessage","decrypt","encryptedData","privateKey","recieverPrivateKeyUint8Array","nacl_decodeHex","recieverEncryptionPrivateKey","fromSecretKey","decryptedMessage","open","encodeUTF8","decryptSafely","parse","getEncryptionPublicKey","privateKeyUint8Array","encryptionPublicKey","msgHex","msgBase64","from","toString"],"sourceRoot":"","sources":["../src/encryption.ts"],"sourcesContent":["import * as nacl from 'tweetnacl';\nimport * as naclUtil from 'tweetnacl-util';\n\nimport { isNullish } from './utils';\n\nexport interface EthEncryptedData {\n  version: string;\n  nonce: string;\n  ephemPublicKey: string;\n  ciphertext: string;\n}\n\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encrypt({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      if (typeof data !== 'string') {\n        throw new Error('Message data must be given as a string');\n      }\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair();\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array;\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n      } catch (err) {\n        throw new Error('Bad public key');\n      }\n\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n      const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey,\n      );\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage),\n      };\n      // return encrypted msg data\n      return output;\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encryptSafely({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error(\n      'Cannot encrypt with toJSON property.  Please remove toJSON property',\n    );\n  }\n\n  // add padding\n  const dataWithPadding = {\n    data,\n    padding: '',\n  };\n\n  // calculate padding\n  const dataLength = Buffer.byteLength(\n    JSON.stringify(dataWithPadding),\n    'utf-8',\n  );\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n  dataWithPadding.padding = '0'.repeat(padLength);\n\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({ publicKey, data: paddedMessage, version });\n}\n\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decrypt({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // string to buffer to UInt8Array\n      const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n      const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(\n        recieverPrivateKeyUint8Array,\n      ).secretKey;\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey,\n      );\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey,\n      );\n\n      // return decrypted msg data\n      let output;\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage);\n      } catch (err) {\n        throw new Error('Decryption failed.');\n      }\n\n      if (output) {\n        return output;\n      }\n      throw new Error('Decryption failed.');\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decryptSafely({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n  return dataWithPadding.data;\n}\n\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nexport function getEncryptionPublicKey(privateKey: string): string {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey =\n    nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex: string): Uint8Array {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}\n"]},"metadata":{},"sourceType":"script"}